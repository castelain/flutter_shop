"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const buildPluginAsset_1 = require("./buildPluginAsset");
const hash_sum_1 = __importDefault(require("hash-sum"));
const cssUtils_1 = require("../utils/cssUtils");
const debug = require('debug')('vite:build:css');
const cssInjectionMarker = `__VITE_CSS__`;
const cssInjectionRE = /__VITE_CSS__\(\)/g;
exports.createBuildCssPlugin = (root, publicBase, assetsDir, minify = false, inlineLimit = 0, cssCodeSplit = true) => {
    const styles = new Map();
    const assets = new Map();
    return {
        name: 'vite:css',
        async transform(css, id) {
            if (id.endsWith('.css') || cssUtils_1.cssPreprocessLangRE.test(id)) {
                const result = await cssUtils_1.compileCss(root, id, {
                    id: '',
                    source: css,
                    filename: path_1.default.basename(id),
                    scoped: false,
                    modules: id.endsWith('.module.css'),
                    preprocessLang: id.replace(cssUtils_1.cssPreprocessLangRE, '$2')
                });
                let modules;
                if (typeof result === 'string') {
                    css = result;
                }
                else {
                    if (result.errors.length) {
                        console.error(`[vite] error applying css transforms: `);
                        result.errors.forEach(console.error);
                    }
                    css = result.code;
                    modules = result.modules;
                }
                // process url() - register referenced files as assets
                // and rewrite the url to the resolved public path
                if (cssUtils_1.urlRE.test(css)) {
                    const fileDir = path_1.default.dirname(id);
                    css = await cssUtils_1.rewriteCssUrls(css, async (rawUrl) => {
                        const file = path_1.default.posix.isAbsolute(rawUrl)
                            ? path_1.default.join(root, rawUrl)
                            : path_1.default.join(fileDir, rawUrl);
                        const { fileName, content, url } = await buildPluginAsset_1.resolveAsset(file, root, publicBase, assetsDir, inlineLimit);
                        if (fileName && content) {
                            assets.set(fileName, content);
                        }
                        debug(`url(${rawUrl}) -> ${url.startsWith('data:') ? `base64 inlined` : `url(${url})`}`);
                        return url;
                    });
                }
                styles.set(id, css);
                return {
                    code: modules
                        ? `export default ${JSON.stringify(modules)}`
                        : cssCodeSplit
                            ? // If code-splitting CSS, inject a fake marker to avoid the module
                                // from being tree-shaken. This preserves the .css file as a
                                // module in the chunk's metadata so that we can retrive them in
                                // renderChunk.
                                `${cssInjectionMarker}()\n`
                            : ``,
                    map: null
                };
            }
        },
        async renderChunk(code, chunk) {
            if (!cssCodeSplit) {
                return null;
            }
            // for each dynamic entry chunk, collect its css and inline it as JS
            // strings.
            if (chunk.isDynamicEntry) {
                let chunkCSS = '';
                for (const id in chunk.modules) {
                    if (styles.has(id)) {
                        chunkCSS += styles.get(id);
                        styles.delete(id); // remove inlined css
                    }
                }
                chunkCSS = await minifyCSS(chunkCSS);
                let isFirst = true;
                code = code.replace(cssInjectionRE, () => {
                    if (isFirst) {
                        isFirst = false;
                        // make sure the code is in one line so that source map is preserved.
                        return (`let ${cssInjectionMarker} = document.createElement('style');` +
                            `${cssInjectionMarker}.innerHTML = ${JSON.stringify(chunkCSS)};` +
                            `document.head.appendChild(${cssInjectionMarker});`);
                    }
                    else {
                        return '';
                    }
                });
            }
            else {
                code = code.replace(cssInjectionRE, '');
            }
            return {
                code,
                map: null
            };
        },
        async generateBundle(_options, bundle) {
            let css = '';
            // finalize extracted css
            styles.forEach((s) => {
                css += s;
            });
            // minify with cssnano
            if (minify) {
                css = await minifyCSS(css);
            }
            const cssFileName = `style.${hash_sum_1.default(css)}.css`;
            bundle[cssFileName] = {
                isAsset: true,
                type: 'asset',
                fileName: cssFileName,
                source: css
            };
            buildPluginAsset_1.registerAssets(assets, bundle);
        }
    };
};
let postcss;
let cssnano;
async function minifyCSS(css) {
    postcss = postcss || require('postcss');
    cssnano = cssnano || require('cssnano');
    return (await postcss(cssnano).process(css, { from: undefined })).css;
}
//# sourceMappingURL=buildPluginCss.js.map