"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const slash_1 = __importDefault(require("slash"));
const utils_1 = require("./utils");
const serverPluginModuleResolve_1 = require("./server/serverPluginModuleResolve");
const depOptimizer_1 = require("./depOptimizer");
const chalk_1 = __importDefault(require("chalk"));
const debug = require('debug')('vite:resolve');
exports.supportedExts = ['.mjs', '.js', '.ts', '.jsx', '.tsx', '.json'];
const defaultRequestToFile = (publicPath, root) => {
    if (serverPluginModuleResolve_1.moduleRE.test(publicPath)) {
        const id = publicPath.replace(serverPluginModuleResolve_1.moduleRE, '');
        const cachedNodeModule = serverPluginModuleResolve_1.idToFileMap.get(id);
        if (cachedNodeModule) {
            return cachedNodeModule;
        }
        // try to resolve from optimized modules
        const optimizedModule = resolveOptimizedModule(root, id);
        if (optimizedModule) {
            return optimizedModule;
        }
        // try to resolve from normal node_modules
        const nodeModule = resolveNodeModuleFile(root, id);
        if (nodeModule) {
            serverPluginModuleResolve_1.idToFileMap.set(id, nodeModule);
            return nodeModule;
        }
    }
    const publicDirPath = path_1.default.join(root, 'public', publicPath.slice(1));
    if (fs_1.default.existsSync(publicDirPath)) {
        return publicDirPath;
    }
    return path_1.default.join(root, publicPath.slice(1));
};
const defaultFileToRequest = (filePath, root) => {
    const moduleRequest = serverPluginModuleResolve_1.fileToRequestMap.get(filePath);
    if (moduleRequest) {
        return moduleRequest;
    }
    return `/${slash_1.default(path_1.default.relative(root, filePath))}`;
};
const isFile = (file) => {
    try {
        return fs_1.default.statSync(file).isFile();
    }
    catch (e) {
        return false;
    }
};
exports.resolveExt = (id) => {
    const cleanId = utils_1.cleanUrl(id);
    if (!isFile(cleanId)) {
        let inferredExt = '';
        for (const ext of exports.supportedExts) {
            if (isFile(cleanId + ext)) {
                inferredExt = ext;
                break;
            }
            if (isFile(path_1.default.join(cleanId, '/index' + ext))) {
                inferredExt = '/index' + ext;
                break;
            }
        }
        const queryMatch = id.match(/\?.*$/);
        const query = queryMatch ? queryMatch[0] : '';
        const resolved = cleanId + inferredExt + query;
        if (resolved !== id) {
            debug(`(extension) ${id} -> ${resolved}`);
        }
        return resolved;
    }
    return id;
};
function createResolver(root, resolvers = [], alias = {}) {
    return {
        requestToFile: (publicPath) => {
            let resolved;
            for (const r of resolvers) {
                const filepath = r.requestToFile && r.requestToFile(publicPath, root);
                if (filepath) {
                    resolved = filepath;
                    break;
                }
            }
            if (!resolved) {
                resolved = defaultRequestToFile(publicPath, root);
            }
            resolved = exports.resolveExt(resolved);
            return resolved;
        },
        fileToRequest: (filePath) => {
            for (const r of resolvers) {
                const request = r.fileToRequest && r.fileToRequest(filePath, root);
                if (request)
                    return request;
            }
            return defaultFileToRequest(filePath, root);
        },
        alias: (id) => {
            let aliased = alias[id];
            if (aliased) {
                return aliased;
            }
            for (const r of resolvers) {
                aliased = r.alias && r.alias(id);
                if (aliased) {
                    return aliased;
                }
            }
        }
    };
}
exports.createResolver = createResolver;
exports.jsSrcRE = /\.(?:(?:j|t)sx?|vue)$|\.mjs$/;
const deepImportRE = /^([^@][^/]*)\/|^(@[^/]+\/[^/]+)\//;
/**
 * Redirects a bare module request to a full path under /@modules/
 * It resolves a bare node module id to its full entry path so that relative
 * imports from the entry can be correctly resolved.
 * e.g.:
 * - `import 'foo'` -> `import '/@modules/foo/dist/index.js'`
 * - `import 'foo/bar/baz'` -> `import '/@modules/foo/bar/baz'`
 */
function resolveBareModuleRequest(root, id, importer) {
    const optimized = resolveOptimizedModule(root, id);
    if (optimized) {
        return id;
    }
    const pkgInfo = resolveNodeModule(root, id);
    if (pkgInfo) {
        if (!pkgInfo.entry) {
            console.error(chalk_1.default.yellow(`[vite] dependency ${id} does not have default entry defined in ` +
                `package.json.`));
        }
        return pkgInfo.entry || id;
    }
    // check and warn deep imports on optimized modules
    const ext = path_1.default.extname(id);
    if (!ext || exports.jsSrcRE.test(ext)) {
        const deepMatch = id.match(deepImportRE);
        if (deepMatch) {
            const depId = deepMatch[1] || deepMatch[2];
            if (resolveOptimizedModule(root, depId)) {
                console.error(chalk_1.default.yellow(`\n[vite] Avoid deep import "${id}" since "${depId}" is a ` +
                    `pre-optimized dependency.\n` +
                    `Prefer importing from the module directly.\n` +
                    `Importer: ${importer}\n`));
            }
        }
        return id;
    }
    else {
        // append import query for non-js deep imports
        return id + (utils_1.queryRE.test(id) ? '&import' : '?import');
    }
}
exports.resolveBareModuleRequest = resolveBareModuleRequest;
const viteOptimizedMap = new Map();
function resolveOptimizedModule(root, id) {
    const cached = viteOptimizedMap.get(id);
    if (cached) {
        return cached;
    }
    const cacheDir = depOptimizer_1.resolveOptimizedCacheDir(root);
    if (!cacheDir)
        return;
    const file = path_1.default.join(cacheDir, id);
    if (fs_1.default.existsSync(file)) {
        viteOptimizedMap.set(id, file);
        return file;
    }
}
exports.resolveOptimizedModule = resolveOptimizedModule;
const nodeModulesInfoMap = new Map();
const nodeModulesFileMap = new Map();
function resolveNodeModule(root, id) {
    const cached = nodeModulesInfoMap.get(id);
    if (cached) {
        return cached;
    }
    let pkgPath;
    try {
        // see if the id is a valid package name
        pkgPath = utils_1.resolveFrom(root, `${id}/package.json`);
    }
    catch (e) { }
    if (pkgPath) {
        // if yes, this is a entry import. resolve entry file
        let pkg;
        try {
            pkg = JSON.parse(fs_1.default.readFileSync(pkgPath, 'utf-8'));
        }
        catch (e) {
            return;
        }
        let entryPoint;
        if (pkg.exports) {
            if (typeof pkg.exports === 'string') {
                entryPoint = pkg.exports;
            }
            else if (pkg.exports['.']) {
                if (typeof pkg.exports['.'] === 'string') {
                    entryPoint = pkg.exports['.'];
                }
                else {
                    entryPoint = pkg.exports['.'].import;
                }
            }
        }
        if (!entryPoint) {
            entryPoint = pkg.module || pkg.main || null;
        }
        debug(`(node_module entry) ${id} -> ${entryPoint}`);
        // save resolved entry file path using the deep import path as key
        // e.g. foo/dist/foo.js
        // this is the path raw imports will be rewritten to, and is what will
        // be passed to resolveNodeModuleFile().
        let entryFilePath = null;
        if (entryPoint) {
            // #284 some packages specify entry without extension...
            if (!path_1.default.extname(entryPoint)) {
                entryPoint += '.js';
            }
            entryFilePath = path_1.default.join(path_1.default.dirname(pkgPath), entryPoint);
            entryPoint = path_1.default.posix.join(id, entryPoint);
            // save the resolved file path now so we don't need to do it again in
            // resolveNodeModuleFile()
            nodeModulesFileMap.set(entryPoint, entryFilePath);
        }
        const result = {
            entry: entryPoint,
            entryFilePath,
            pkg
        };
        nodeModulesInfoMap.set(id, result);
        return result;
    }
}
exports.resolveNodeModule = resolveNodeModule;
function resolveNodeModuleFile(root, id) {
    const cached = nodeModulesFileMap.get(id);
    if (cached) {
        return cached;
    }
    try {
        const resolved = utils_1.resolveFrom(root, id);
        nodeModulesFileMap.set(id, resolved);
        return resolved;
    }
    catch (e) {
        // error will be reported downstream
    }
}
exports.resolveNodeModuleFile = resolveNodeModuleFile;
//# sourceMappingURL=resolver.js.map