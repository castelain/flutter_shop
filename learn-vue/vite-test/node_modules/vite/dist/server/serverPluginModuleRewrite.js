"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const magic_string_1 = __importDefault(require("magic-string"));
const es_module_lexer_1 = require("es-module-lexer");
const resolver_1 = require("../resolver");
const serverPluginHmr_1 = require("./serverPluginHmr");
const utils_1 = require("../utils");
const chalk_1 = __importDefault(require("chalk"));
const slash_1 = __importDefault(require("slash"));
const serverPluginModuleResolve_1 = require("./serverPluginModuleResolve");
const debug = require('debug')('vite:rewrite');
const rewriteCache = new lru_cache_1.default({ max: 1024 });
// Plugin for rewriting served js.
// - Rewrites named module imports to `/@modules/:id` requests, e.g.
//   "vue" => "/@modules/vue"
// - Rewrites files containing HMR code (reference to `import.meta.hot`) to
//   inject `import.meta.hot` and track HMR boundary accept whitelists.
// - Also tracks importer/importee relationship graph during the rewrite.
//   The graph is used by the HMR plugin to perform analysis on file change.
exports.moduleRewritePlugin = ({ root, app, watcher, resolver }) => {
    app.use(async (ctx, next) => {
        await next();
        if (ctx.status === 304) {
            return;
        }
        // we are doing the js rewrite after all other middlewares have finished;
        // this allows us to post-process javascript produced by user middlewares
        // regardless of the extension of the original files.
        if (ctx.body &&
            ctx.response.is('js') &&
            !ctx.url.endsWith('.map') &&
            // skip internal client
            !ctx.path.startsWith(serverPluginHmr_1.hmrClientPublicPath) &&
            // only need to rewrite for <script> part in vue files
            !((ctx.path.endsWith('.vue') || ctx.vue) && ctx.query.type != null)) {
            const content = await utils_1.readBody(ctx.body);
            if (!ctx.query.t && rewriteCache.has(content)) {
                debug(`(cached) ${ctx.url}`);
                ctx.body = rewriteCache.get(content);
            }
            else {
                await es_module_lexer_1.init;
                ctx.body = rewriteImports(root, content, ctx.path, resolver, ctx.query.t);
                rewriteCache.set(content, ctx.body);
            }
        }
        else {
            debug(`(skipped) ${ctx.url}`);
        }
    });
    // bust module rewrite cache on file change
    watcher.on('change', (file) => {
        const publicPath = resolver.fileToRequest(file);
        debug(`${publicPath}: cache busted`);
        rewriteCache.del(publicPath);
    });
};
function rewriteImports(root, source, importer, resolver, timestamp) {
    if (typeof source !== 'string') {
        source = String(source);
    }
    try {
        let imports = [];
        try {
            imports = es_module_lexer_1.parse(source)[0];
        }
        catch (e) {
            console.error(chalk_1.default.yellow(`[vite] failed to parse ${chalk_1.default.cyan(importer)} for import rewrite.\nIf you are using ` +
                `JSX, make sure to named the file with the .jsx extension.`));
        }
        if (imports.length) {
            debug(`${importer}: rewriting`);
            const s = new magic_string_1.default(source);
            let hasReplaced = false;
            let hasRewrittenForHMR = false;
            const prevImportees = serverPluginHmr_1.importeeMap.get(importer);
            const currentImportees = new Set();
            serverPluginHmr_1.importeeMap.set(importer, currentImportees);
            for (let i = 0; i < imports.length; i++) {
                const { s: start, e: end, d: dynamicIndex } = imports[i];
                let id = source.substring(start, end);
                let hasLiteralDynamicId = false;
                if (dynamicIndex >= 0) {
                    const literalIdMatch = id.match(/^(?:'([^']+)'|"([^"]+)")$/);
                    if (literalIdMatch) {
                        hasLiteralDynamicId = true;
                        id = literalIdMatch[1] || literalIdMatch[2];
                    }
                }
                if (dynamicIndex === -1 || hasLiteralDynamicId) {
                    // do not rewrite external imports
                    if (utils_1.isExternalUrl(id)) {
                        continue;
                    }
                    const resolved = exports.resolveImport(root, importer, id, resolver, timestamp);
                    if (resolved !== id) {
                        debug(`    "${id}" --> "${resolved}"`);
                        s.overwrite(start, end, hasLiteralDynamicId ? `'${resolved}'` : resolved);
                        hasReplaced = true;
                    }
                    // save the import chain for hmr analysis
                    const importee = utils_1.cleanUrl(resolved);
                    if (importee !== importer &&
                        // no need to track hmr client or module dependencies
                        importee !== serverPluginHmr_1.hmrClientPublicPath) {
                        currentImportees.add(importee);
                        serverPluginHmr_1.debugHmr(`        ${importer} imports ${importee}`);
                        serverPluginHmr_1.ensureMapEntry(serverPluginHmr_1.importerMap, importee).add(importer);
                    }
                }
                else {
                    if (id === 'import.meta') {
                        if (!hasRewrittenForHMR &&
                            source.substring(start, end + 4) === 'import.meta.hot') {
                            serverPluginHmr_1.debugHmr(`rewriting ${importer} for HMR.`);
                            serverPluginHmr_1.rewriteFileWithHMR(root, source, importer, resolver, s);
                            hasRewrittenForHMR = true;
                            hasReplaced = true;
                        }
                    }
                    else {
                        debug(`[vite] ignored dynamic import(${id})`);
                    }
                }
            }
            // since the importees may have changed due to edits,
            // check if we need to remove this importer from certain importees
            if (prevImportees) {
                prevImportees.forEach((importee) => {
                    if (!currentImportees.has(importee)) {
                        const importers = serverPluginHmr_1.importerMap.get(importee);
                        if (importers) {
                            importers.delete(importer);
                        }
                    }
                });
            }
            if (!hasReplaced) {
                debug(`    no imports rewritten.`);
            }
            return hasReplaced ? s.toString() : source;
        }
        else {
            debug(`${importer}: no imports found.`);
        }
        return source;
    }
    catch (e) {
        console.error(`[vite] Error: module imports rewrite failed for ${importer}.\n`, e);
        debug(source);
        return source;
    }
}
exports.rewriteImports = rewriteImports;
const bareImportRE = /^[^\/\.]/;
const indexRE = /\/index\.\w+$/;
const indexRemoveRE = /\/index(\.\w+)?$/;
exports.resolveImport = (root, importer, id, resolver, timestamp) => {
    id = resolver.alias(id) || id;
    if (bareImportRE.test(id)) {
        // directly resolve bare module names to its entry path so that relative
        // imports from it (including source map urls) can work correctly
        return `/@modules/${resolver_1.resolveBareModuleRequest(root, id, importer)}`;
    }
    else {
        // 1. relative to absolute
        //    ./foo -> /some/path/foo
        let { pathname, query } = utils_1.resolveRelativeRequest(importer, id);
        // 2. if this is a relative import between files under /@modules/, preserve
        // them as-is
        if (serverPluginModuleResolve_1.moduleRE.test(pathname)) {
            return pathname;
        }
        // 3. resolve extensions.
        const file = slash_1.default(resolver.requestToFile(pathname));
        const resolvedExt = path_1.default.extname(file);
        if (resolvedExt !== path_1.default.extname(pathname)) {
            const indexMatch = file.match(indexRE);
            if (indexMatch) {
                pathname = pathname.replace(indexRemoveRE, '') + indexMatch[0];
            }
            else {
                pathname += resolvedExt;
            }
        }
        // 4. mark non-src imports
        if (!query && path_1.default.extname(pathname) && !resolver_1.jsSrcRE.test(pathname)) {
            query += `?import`;
        }
        // 5. force re-fetch dirty imports by appending timestamp
        if (timestamp) {
            const dirtyFiles = serverPluginHmr_1.hmrDirtyFilesMap.get(timestamp);
            // only rewrite if:
            if (dirtyFiles && dirtyFiles.has(pathname)) {
                // 1. this is a marked dirty file (in the import chain of the changed file)
                query += `${query ? `&` : `?`}t=${timestamp}`;
            }
            else if (serverPluginHmr_1.latestVersionsMap.has(pathname)) {
                // 2. this file was previously hot-updated and has an updated version
                query += `${query ? `&` : `?`}t=${serverPluginHmr_1.latestVersionsMap.get(pathname)}`;
            }
        }
        return pathname + query;
    }
};
//# sourceMappingURL=serverPluginModuleRewrite.js.map