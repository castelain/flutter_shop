"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const hash_sum_1 = __importDefault(require("hash-sum"));
const utils_1 = require("../utils");
const serverPluginVue_1 = require("./serverPluginVue");
const cssUtils_1 = require("../utils/cssUtils");
const querystring_1 = __importDefault(require("querystring"));
const chalk_1 = __importDefault(require("chalk"));
exports.debugCSS = require('debug')('vite:css');
const processedCSS = new Map();
exports.cssPlugin = ({ root, app, watcher, resolver }) => {
    app.use(async (ctx, next) => {
        await next();
        // handle .css imports
        if ((cssUtils_1.cssPreprocessLangRE.test(ctx.path) || ctx.response.is('css')) &&
            // note ctx.body could be null if upstream set status to 304
            ctx.body) {
            const id = JSON.stringify(hash_sum_1.default(ctx.path));
            if (utils_1.isImportRequest(ctx)) {
                await processCss(root, ctx);
                // we rewrite css with `?import` to a js module that inserts a style
                // tag linking to the actual raw url
                ctx.type = 'js';
                const { css, modules } = processedCSS.get(ctx.path);
                ctx.body = cssUtils_1.codegenCss(id, css, modules);
            }
            else {
                // raw request, return compiled css
                if (!processedCSS.has(ctx.path)) {
                    await processCss(root, ctx);
                }
                ctx.type = 'css';
                ctx.body = processedCSS.get(ctx.path).css;
            }
        }
    });
    watcher.on('change', (filePath) => {
        if (filePath.endsWith('.css') || cssUtils_1.cssPreprocessLangRE.test(filePath)) {
            const publicPath = resolver.fileToRequest(filePath);
            /** filter unused files */
            if (!processedCSS.has(publicPath) && !serverPluginVue_1.srcImportMap.has(filePath)) {
                return exports.debugCSS(`${path_1.basename(publicPath)} has changed, but it is not currently in use`);
            }
            if (serverPluginVue_1.srcImportMap.has(filePath)) {
                // handle HMR for <style src="xxx.css">
                // it cannot be handled as simple css import because it may be scoped
                const styleImport = serverPluginVue_1.srcImportMap.get(filePath);
                serverPluginVue_1.vueCache.del(filePath);
                const publicPath = utils_1.cleanUrl(styleImport);
                const index = querystring_1.default.parse(styleImport.split('?', 2)[1]).index;
                console.log(chalk_1.default.green(`[vite:hmr] `) + `${publicPath} updated. (style)`);
                watcher.send({
                    type: 'style-update',
                    path: `${publicPath}?type=style&index=${index}`,
                    timestamp: Date.now()
                });
                return;
            }
            // handle HMR for module.css
            // it cannot process with normal css, the class which in module.css maybe removed
            if (filePath.endsWith('.module.css')) {
                watcher.handleJSReload(filePath, Date.now());
                return;
            }
            // bust process cache
            processedCSS.delete(publicPath);
            watcher.send({
                type: 'style-update',
                path: publicPath,
                timestamp: Date.now()
            });
        }
    });
    async function processCss(root, ctx) {
        let css = (await utils_1.readBody(ctx.body));
        const result = await cssUtils_1.compileCss(root, ctx.path, {
            id: '',
            source: css,
            filename: resolver.requestToFile(ctx.path),
            scoped: false,
            modules: ctx.path.endsWith('.module.css'),
            preprocessLang: ctx.path.replace(cssUtils_1.cssPreprocessLangRE, '$2')
        });
        if (typeof result === 'string') {
            processedCSS.set(ctx.path, { css });
            return;
        }
        if (result.errors.length) {
            console.error(`[vite] error applying css transforms: `);
            result.errors.forEach(console.error);
        }
        result.code = await cssUtils_1.rewriteCssUrls(result.code, ctx.path);
        processedCSS.set(ctx.path, {
            css: result.code,
            modules: result.modules
        });
    }
};
//# sourceMappingURL=serverPluginCss.js.map